/**
 * Sprite Collection System
 * 
 * File-based collection discovery for sprite collections.
 * Collections are organized as: public/sprites/{collection-name}/*.svg
 * The "default" collection uses existing shape-based rendering.
 * 
 * SVG collections are AUTOMATICALLY discovered and updated:
 * - Collections are automatically regenerated when files in public/sprites/ change
 * - No manual steps required - just add a folder with SVG files!
 * - The vite-plugin-sprite-collections.ts plugin watches for changes and updates collections automatically
 * - UI and canvas rendering automatically reflect new collections via HMR
 */

import type { SpriteMode } from "../types/generator";
import { SPRITE_MODES } from "./sprites";
import { autoGeneratedCollections } from "./spriteCollections.generated";

export interface SpriteInfo {
  id: string;
  name: string; // Display name (sanitized from filename)
  svgPath?: string; // Path to SVG file (only for SVG-based sprites)
  spriteMode?: SpriteMode; // For default collection
}

export interface SpriteCollection {
  id: string;
  label: string; // Display name (capitalized collection name)
  isShapeBased: boolean; // true for default, false for SVG collections
  sprites: SpriteInfo[];
}

// SVG collections are automatically generated from public/sprites/ directory
// Collections are automatically regenerated by vite-plugin-sprite-collections.ts
// when files change - no manual steps needed!
// This import is reactive - when the generated file updates, this module will reload
const manualSvgCollections: Array<{
  collectionId: string;
  sprites: Array<{ id: string; name: string; svgPath: string }>;
}> = autoGeneratedCollections;

/**
 * Sanitize filename to display name
 * Converts "christmas-tree.svg" -> "Christmas Tree"
 */
function sanitizeSpriteName(filename: string): string {
  // Remove extension
  const name = filename.replace(/\.svg$/i, '');
  // Replace hyphens/underscores with spaces
  const withSpaces = name.replace(/[-_]/g, ' ');
  // Capitalize words
  return withSpaces
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Extract collection ID from path
 * "/sprites/christmas/snowflake.svg" or "/public/sprites/christmas/snowflake.svg" -> "christmas"
 */
function extractCollectionId(path: string): string {
  const match = path.match(/\/sprites\/([^/]+)\//);
  return match ? match[1] : '';
}

/**
 * Extract sprite ID from path
 * "/sprites/christmas/snowflake.svg" -> "snowflake"
 */
function extractSpriteId(path: string): string {
  const match = path.match(/\/([^/]+)\.svg$/);
  return match ? match[1] : '';
}

/**
 * Build collections from manual definitions
 */
function buildCollectionsFromManual(): Map<string, SpriteCollection> {
  const collections = new Map<string, SpriteCollection>();

  // Process manual SVG collection definitions
  for (const manualCollection of manualSvgCollections) {
    // Capitalize collection name for display
    const label = manualCollection.collectionId
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
    
    const collection: SpriteCollection = {
      id: manualCollection.collectionId,
      label,
      isShapeBased: false,
      sprites: manualCollection.sprites.map(sprite => ({
        id: sprite.id,
        name: sprite.name,
        svgPath: sprite.svgPath,
      })),
    };
    
    collections.set(manualCollection.collectionId, collection);
  }

  return collections;
}

/**
 * Create default collection from existing SPRITE_MODES
 */
function createDefaultCollection(): SpriteCollection {
  return {
    id: 'default',
    label: 'Default',
    isShapeBased: false,
    sprites: SPRITE_MODES.map(mode => ({
      id: mode.value,
      name: mode.label,
      svgPath: mode.svgPath,
    })),
  };
}

/**
 * Build all collections map dynamically
 * This function is called each time to ensure we always have the latest collections
 */
function buildAllCollectionsMap(): Map<string, SpriteCollection> {
  const map = buildCollectionsFromManual();
// Always add default collection first
  map.set('default', createDefaultCollection());
  return map;
}

/**
 * Get all available collections
 * Rebuilds the map each time to ensure it's always up-to-date with the latest generated collections.
 * When autoGeneratedCollections changes (via HMR), this will return the new collections.
 */
export function getAllCollections(): SpriteCollection[] {
  const allCollectionsMap = buildAllCollectionsMap();
  return Array.from(allCollectionsMap.values());
}

/**
 * Get a specific collection by ID
 * Rebuilds the map to ensure we have the latest collections.
 */
export function getCollection(collectionId: string): SpriteCollection | undefined {
  const allCollectionsMap = buildAllCollectionsMap();
  return allCollectionsMap.get(collectionId);
}

/**
 * Get a specific sprite within a collection
 */
export function getSpriteInCollection(
  collectionId: string,
  spriteId: string
): SpriteInfo | undefined {
  const collection = getCollection(collectionId);
  return collection?.sprites.find(sprite => sprite.id === spriteId);
}

/**
 * Check if a collection is shape-based (default) or SVG-based
 */
export function isShapeBasedCollection(collectionId: string): boolean {
  return false; // All collections now use SVG-based rendering
}

/**
 * Get sprite identifier for a sprite
 * Returns "shape:mode" for shape sprites, or svgPath for SVG sprites
 */
export function getSpriteIdentifier(sprite: SpriteInfo, collectionId: string): string {
  if (sprite.svgPath) {
    return sprite.svgPath;
  }
  if (sprite.spriteMode) {
    return `shape:${sprite.spriteMode}`;
  }
  // Fallback: use collection and id
  return `${collectionId}:${sprite.id}`;
}

/**
 * Find a sprite by its identifier across all collections
 * Identifier format: "shape:mode" for shapes, or svgPath for SVG sprites
 */
export function findSpriteByIdentifier(identifier: string): { sprite: SpriteInfo; collectionId: string } | null {
  // Check if it's a shape identifier
  if (identifier.startsWith("shape:")) {
    const shapeMode = identifier.replace("shape:", "") as SpriteMode;
    const defaultCollection = getCollection("default");
    if (defaultCollection) {
      const sprite = defaultCollection.sprites.find(s => s.spriteMode === shapeMode);
      if (sprite) {
        return { sprite, collectionId: "default" };
      }
    }
    return null;
  }
  
  // It's an svgPath - search all collections
  const allCollections = getAllCollections();
  for (const collection of allCollections) {
    const sprite = collection.sprites.find(s => s.svgPath === identifier);
    if (sprite) {
      return { sprite, collectionId: collection.id };
    }
  }
  
  return null;
}

/**
 * Get sprite identifier from sprite mode and collection
 * Used to convert UI sprite selection to internal identifier format
 */
export function getSpriteIdentifierFromMode(spriteMode: SpriteMode, collectionId: string): string | null {
  const collection = getCollection(collectionId);
  if (!collection) {
    return null;
  }
  
  if (collection.isShapeBased) {
    // Shape-based sprite - return "shape:mode"
    return `shape:${spriteMode}`;
  }
  
  // SVG collection - find the sprite and return its svgPath
  const sprite = getSpriteInCollection(collectionId, spriteMode);
  if (sprite?.svgPath) {
    return sprite.svgPath;
  }
  
  return null;
}

