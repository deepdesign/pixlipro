/**
 * Sprite Collection System
 * 
 * File-based collection discovery for sprite collections.
 * Collections are organized as: public/sprites/{collection-name}/*.svg
 * The "default" collection uses existing shape-based rendering.
 * 
 * SVG collections are AUTOMATICALLY discovered and updated:
 * - Collections are automatically regenerated when files in public/sprites/ change
 * - No manual steps required - just add a folder with SVG files!
 * - The vite-plugin-sprite-collections.ts plugin watches for changes and updates collections automatically
 * - UI and canvas rendering automatically reflect new collections via HMR
 */

import type { SpriteMode } from "../types/generator";
import { SPRITE_MODES } from "./sprites";
import { autoGeneratedCollections } from "./spriteCollections.generated";
import { getAllCustomCollections } from "@/lib/storage/customSpriteStorage";

// Cache for blob URLs to prevent memory leaks
const blobUrlCache = new Map<string, string>();

export interface SpriteInfo {
  id: string;
  name: string; // Display name (sanitized from filename)
  svgPath?: string; // Path to SVG file (only for SVG-based sprites)
  svgContent?: string; // SVG content string (for custom sprites from localStorage)
  spriteMode?: SpriteMode; // For default collection
}

export interface SpriteCollection {
  id: string;
  label: string; // Display name (capitalized collection name)
  isShapeBased: boolean; // true for default, false for SVG collections
  sprites: SpriteInfo[];
}

// SVG collections are automatically generated from public/sprites/ directory
// Collections are automatically regenerated by vite-plugin-sprite-collections.ts
// when files change - no manual steps needed!
// This import is reactive - when the generated file updates, this module will reload
const manualSvgCollections: Array<{
  collectionId: string;
  sprites: Array<{ id: string; name: string; svgPath: string }>;
}> = autoGeneratedCollections;

/**
 * Sanitize filename to display name
 * Converts "christmas-tree.svg" -> "Christmas Tree"
 */
function sanitizeSpriteName(filename: string): string {
  // Remove extension
  const name = filename.replace(/\.svg$/i, '');
  // Replace hyphens/underscores with spaces
  const withSpaces = name.replace(/[-_]/g, ' ');
  // Capitalize words
  return withSpaces
    .split(' ')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');
}

/**
 * Extract collection ID from path
 * "/sprites/christmas/snowflake.svg" or "/public/sprites/christmas/snowflake.svg" -> "christmas"
 */
function extractCollectionId(path: string): string {
  const match = path.match(/\/sprites\/([^/]+)\//);
  return match ? match[1] : '';
}

/**
 * Extract sprite ID from path
 * "/sprites/christmas/snowflake.svg" -> "snowflake"
 */
function extractSpriteId(path: string): string {
  const match = path.match(/\/([^/]+)\.svg$/);
  return match ? match[1] : '';
}

/**
 * Build collections from manual definitions
 */
function buildCollectionsFromManual(): Map<string, SpriteCollection> {
  const collections = new Map<string, SpriteCollection>();

  // Process manual SVG collection definitions
  for (const manualCollection of manualSvgCollections) {
    // Capitalize collection name for display
    const label = manualCollection.collectionId
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
    
    const collection: SpriteCollection = {
      id: manualCollection.collectionId,
      label,
      isShapeBased: false,
      sprites: manualCollection.sprites.map(sprite => ({
        id: sprite.id,
        name: sprite.name,
        svgPath: sprite.svgPath,
      })),
    };
    
    collections.set(manualCollection.collectionId, collection);
  }

  return collections;
}

/**
 * Create default collection from existing SPRITE_MODES
 */
function createDefaultCollection(): SpriteCollection {
  return {
    id: 'default',
    label: 'Default',
    isShapeBased: false,
    sprites: SPRITE_MODES.map(mode => ({
      id: mode.value,
      name: mode.label,
      svgPath: mode.svgPath,
    })),
  };
}

/**
 * Build custom collections from localStorage
 */
function buildCustomCollections(): Map<string, SpriteCollection> {
  const map = new Map<string, SpriteCollection>();
  const customCollections = getAllCustomCollections();

  // Get current custom collection IDs to clean up blob URLs for deleted collections
  const currentCollectionIds = new Set(customCollections.map(c => c.id));
  for (const [key, url] of blobUrlCache.entries()) {
    const collectionId = key.split(':')[0];
    if (!currentCollectionIds.has(collectionId)) {
      // Collection was deleted, clean up its blob URLs
      URL.revokeObjectURL(url);
      blobUrlCache.delete(key);
    }
  }

  for (const customCollection of customCollections) {
    // Get current sprite IDs in this collection
    const currentSpriteIds = new Set(customCollection.sprites.map(s => s.id));
    
    // Clean up blob URLs for deleted sprites in this collection
    for (const [key, url] of blobUrlCache.entries()) {
      if (key.startsWith(`${customCollection.id}:`)) {
        const spriteId = key.split(':')[1];
        if (!currentSpriteIds.has(spriteId)) {
          // Sprite was deleted, clean up its blob URL
          URL.revokeObjectURL(url);
          blobUrlCache.delete(key);
        }
      }
    }

    // Generate blob URLs for custom sprites (cached to prevent memory leaks)
    const sprites: SpriteInfo[] = customCollection.sprites.map(sprite => {
      // Use cache key based on collection ID and sprite ID
      const cacheKey = `${customCollection.id}:${sprite.id}`;
      
      // Check if we already have a blob URL for this sprite
      let blobUrl = blobUrlCache.get(cacheKey);
      if (!blobUrl) {
        // Create new blob URL and cache it
        const blob = new Blob([sprite.svgContent], { type: 'image/svg+xml' });
        blobUrl = URL.createObjectURL(blob);
        blobUrlCache.set(cacheKey, blobUrl);
      }
      
      return {
        id: sprite.id,
        name: sprite.name,
        svgPath: blobUrl, // Use blob URL as svgPath
        svgContent: sprite.svgContent, // Also provide SVG content directly for ShapeIcon
      };
    });

    map.set(customCollection.id, {
      id: customCollection.id,
      label: customCollection.name,
      isShapeBased: false,
      sprites,
    });
  }

  return map;
}

/**
 * Clean up blob URLs for a specific collection
 * Call this when a collection is deleted
 */
export function cleanupCollectionBlobUrls(collectionId: string): void {
  for (const [key, url] of blobUrlCache.entries()) {
    if (key.startsWith(`${collectionId}:`)) {
      URL.revokeObjectURL(url);
      blobUrlCache.delete(key);
    }
  }
}

/**
 * Build all collections map dynamically
 * This function is called each time to ensure we always have the latest collections
 */
function buildAllCollectionsMap(): Map<string, SpriteCollection> {
  const map = buildCollectionsFromManual();
// Always add default collection first
  map.set('default', createDefaultCollection());
  
  // Add custom collections from localStorage
  const customMap = buildCustomCollections();
  for (const [id, collection] of customMap.entries()) {
    map.set(id, collection);
  }
  
  return map;
}

/**
 * Get all available collections
 * Rebuilds the map each time to ensure it's always up-to-date with the latest generated collections.
 * When autoGeneratedCollections changes (via HMR), this will return the new collections.
 */
export function getAllCollections(): SpriteCollection[] {
  const allCollectionsMap = buildAllCollectionsMap();
  return Array.from(allCollectionsMap.values());
}

/**
 * Get a specific collection by ID
 * Rebuilds the map to ensure we have the latest collections.
 */
export function getCollection(collectionId: string): SpriteCollection | undefined {
  const allCollectionsMap = buildAllCollectionsMap();
  return allCollectionsMap.get(collectionId);
}

/**
 * Get a specific sprite within a collection
 */
export function getSpriteInCollection(
  collectionId: string,
  spriteId: string
): SpriteInfo | undefined {
  const collection = getCollection(collectionId);
  return collection?.sprites.find(sprite => sprite.id === spriteId);
}

/**
 * Check if a collection is shape-based (default) or SVG-based
 */
export function isShapeBasedCollection(collectionId: string): boolean {
  return false; // All collections now use SVG-based rendering
}

/**
 * Get sprite identifier for a sprite
 * Returns "shape:mode" for shape sprites, or svgPath for SVG sprites
 */
export function getSpriteIdentifier(sprite: SpriteInfo, collectionId: string): string {
  if (sprite.svgPath) {
    return sprite.svgPath;
  }
  if (sprite.spriteMode) {
    return `shape:${sprite.spriteMode}`;
  }
  // Fallback: use collection and id
  return `${collectionId}:${sprite.id}`;
}

/**
 * Find a sprite by its identifier across all collections
 * Identifier format: 
 * - "shape:mode" for shapes
 * - "custom:collectionId:spriteId" for custom sprites
 * - svgPath for file-based SVG sprites
 */
export function findSpriteByIdentifier(identifier: string): { sprite: SpriteInfo; collectionId: string } | null {
  // Check if it's a shape identifier
  if (identifier.startsWith("shape:")) {
    const shapeMode = identifier.replace("shape:", "") as SpriteMode;
    const defaultCollection = getCollection("default");
    if (defaultCollection) {
      const sprite = defaultCollection.sprites.find(s => s.spriteMode === shapeMode);
      if (sprite) {
        return { sprite, collectionId: "default" };
      }
    }
    return null;
  }
  
  // Check if it's a custom sprite identifier
  if (identifier.startsWith("custom:")) {
    const parts = identifier.split(":");
    if (parts.length === 3) {
      const [, collectionId, spriteId] = parts;
      const collection = getCollection(collectionId);
      if (collection) {
        const sprite = collection.sprites.find(s => s.id === spriteId);
        if (sprite) {
          return { sprite, collectionId };
        }
      }
    }
    return null;
  }
  
  // It's an svgPath (file-based sprite) - search all collections
  const allCollections = getAllCollections();
  for (const collection of allCollections) {
    const sprite = collection.sprites.find(s => s.svgPath === identifier);
    if (sprite) {
      return { sprite, collectionId: collection.id };
    }
  }
  
  return null;
}

/**
 * Get sprite identifier from sprite mode and collection
 * Used to convert UI sprite selection to internal identifier format
 * For custom sprites, uses stable format: "custom:collectionId:spriteId"
 * For file-based sprites, uses svgPath
 * For shape sprites, uses "shape:mode"
 */
export function getSpriteIdentifierFromMode(spriteMode: SpriteMode, collectionId: string): string | null {
  const collection = getCollection(collectionId);
  if (!collection) {
    return null;
  }
  
  if (collection.isShapeBased) {
    // Shape-based sprite - return "shape:mode"
    return `shape:${spriteMode}`;
  }
  
  // SVG collection - find the sprite
  const sprite = getSpriteInCollection(collectionId, spriteMode);
  if (!sprite) {
    return null;
  }
  
  // Check if this is a custom collection (has custom prefix in ID or check localStorage)
  const customCollections = getAllCustomCollections();
  const isCustomCollection = customCollections.some(c => c.id === collectionId);
  
  if (isCustomCollection) {
    // Custom sprite - use stable identifier format
    return `custom:${collectionId}:${sprite.id}`;
  }
  
  // File-based sprite - use svgPath (stable file path)
  if (sprite.svgPath) {
    return sprite.svgPath;
  }
  
  return null;
}

